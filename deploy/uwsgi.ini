[uwsgi]
protocol = uwsgi

[uwsgi]
; uwsgi setup
uid = www-data
gid = www-data

; This option tells uWSGI to fail to start if any parameter in the configuration file isn’t explicitly understood by uWSGI.
strict = true

; The master uWSGI process is necessary to gracefully re-spawn and pre-fork workers, consolidate logs, and manage many other features (shared memory, cron jobs, worker timeouts…). Without this feature on, uWSGI is a mere shadow of its true self. This option should always be set to ‘on’ unless you are using the more complex “emperor” system for multi-app deployments or are debugging specific behavior for which you want uWSGI to be limited.
master = true

; A note on Python threads
; If you start uWSGI without threads, the Python GIL will not be enabled, so threads generated by your application will never run. You may not like that choice, but remember that uWSGI is a language-independent server, so most of its choices are for maintaining it “agnostic”. But do not worry, there are basically no choices made by the uWSGI developers that cannot be changed with an option. If you want to maintain Python threads support without starting multiple threads for your application, just add the --enable-threads option (or enable-threads = true in ini style).
enable-threads = true

; By default, uWSGI starts in multiple interpreter mode, which allows multiple services to be hosted in each worker process. Here is an old mailing list post regarding this feature: Multiple interpreters are cool, but there are reports on some c extensions that do not cooperate well with them. When multiple interpreters are enabled, uWSGI will change the whole ThreadState (an internal Python structure) at every request. It is not so slow, but with some kind of app/extensions that could be overkill.
; sGiven the rise of microservices, we have no plans to ever host more than one service in a given worker process, and I doubt you do either. Disabling this feature appears to have no negative impact, while also reducing the odds of compatibility issues that may waste development time or cause production outages.
single-interpreter = true
; By default, uWSGI loads your application and then forks it. But you can specify lazy-apps = true. This way, uWSGI loads your application separately for every worker. It can help avoid errors with TensorFlow models or sharing other data between workers.
; lazy-apps mode in uwsgi: To keep this article general enough, we have used the lazy-apps mode in uwsgi, which loads the application one time per worker. According to the docs, this will require O(n) time to load (where n is the number of workers). It also likely requires more memory but results in a clean environment per worker. By default, uWSGI loads the whole application differently. It starts with one process; then it forks itself multiple times for additional workers. This results in more memory savings. However, this does not play well with all of the ML frameworks. For example, the TensorFlow backend in Keras fails without the lazy-apps mode (e.g., check this, this, and this). The best could be to try first without lazy-apps = true, and shifting to it if you encounter similar issues.
lazy-apps = true
callable = app

; This parameter prevents uWSGI from starting if it is unable to find or load your application module. Without this option, uWSGI will ignore any syntax and import errors thrown at startup and will start an empty shell that will return 500s for all requests. This is especially problematic because monitoring systems may observe that uWSGI started successfully and think the application is available to service requests when, in fact, it is not.
; uWSGI continues to start without your application loaded because it thinks you may load an application dynamically later. This is the default behavior because the dynamic loading of apps used to be common. Here’s a GitHub comment from unbit, the developers of uWSGI, in reference to this behavior:
; …because in 2008-2009 it was the only supported way to configure apps (the webserver instructed the application server about the app to load). If you try to go back to that time (where even the concept of proxying was not so widely approved) you will understand why it was a pretty obvious decision for software aimed at shared hosting.
; Now things have changed, but there are still dozens of customers (paying customers) that use this kind of setup, and by default we do not change default unless after a looooong deprecation phase.
need-app = true

; This option will instruct uWSGI to clean up any temporary files or UNIX sockets it created, such as HTTP sockets, pidfiles, or admin FIFOs. Leaving these files around can pose a problem under some circumstances, such as if a developer runs uWSGI as their own user, and takes ownership of these files. If the production user doesn’t have permission to delete those files, uWSGI may fail to function properly.
vacuum = true

;Till uWSGI 2.1, by default, sending the SIGTERM signal to uWSGI means “brutally reload the stack” while the convention is to shut an application down on SIGTERM. To shutdown uWSGI, use SIGINT or SIGQUIT instead. If you absolutely can not live with uWSGI being so disrespectful towards SIGTERM, by all means, enable the die-on-term option. Fortunately, this bad choice has been fixed in uWSGI 2.1
; You should enable this feature because it makes uWSGI behave in the way that any sane developer would expect. Without it, kill, or any tool that sends SIGTERM (such as some system monitoring tools) would attempt to kill uWSGI without success, confounding the operator of said tools.
die-on-term = true

; app setup
module = wsgi:app
socket = 0.0.0.0:8080
chmod-socket = 664

; workers
# cheaper-algo = spare
# cheaper-algo = busyness
cheaper = 2
processes = %(%k + 1)

; By default, the process names of uWSGI workers are simply the command used to start them.
; uWSGI provides some functionality which can help identify the workers:
auto-procname = true

; This is helpful, but we’ll run into issues if we run more than one uWSGI instance on the same machine.
procname-prefix = "medlocalgpt "  # note the space

; stats
stats = /tmp/medlocalgpt.stats
memory-report = true
; By default, uWSGI has rather verbose logging. It is reasonable to disable uWSGI’s standard logging, especially if your application emits concise and meaningful logs.
disable-logging = true
; Proceed with caution: If you do choose to disable uWSGI’s standard log output, we recommend you use the log-4xx and log-5xx parameters to re-enable uWSGI’s built-in logging for responses with HTTP status codes of 4xx or 5xx. This will ensure that critical errors are always logged, something that is very difficult for an application logger to ensure in the face of unhandled exceptions, unexpected signals, and segfaults in native code.
log-4xx = true
log-5xx = true